# Longstanding SPI used by WebKitLegacy before we started auditing SPI use.
# NEVER add to this list, only remove!

[[legacy]]
classes = [
    "LSAppLink",
    "NSCalendarDate",
    "NSURLDownload",
    "_LSOpenConfiguration",
    "NSURLFileTypeMappings",
]
selectors = [
    { name = "_CFURLCache", class = "?" },
    { name = "_downloadWithLoadingConnection:request:response:delegate:proxy:", class = "?" },
    { name = "_downloadWithRequest:delegate:directory:", class = "?" },
    { name = "_scrollTo:animate:", class = "?" },
    { name = "_web_hasCaseInsensitivePrefix:", class = "?" },
    { name = "_web_removeFileOnlyAtPath:", class = "?" },
    { name = "_web_stringByExpandingTildeInPath", class = "?" },
    { name = "_webthread_webView:didFinishDocumentLoadForFrame:", class = "?" },
    { name = "_webthread_webView:didFinishLoadForFrame:", class = "?" },
    { name = "_webthread_webView:tileDidDraw:", class = "?" },
    { name = "addCommitHandler:forPhase:", class = "?" },
    { name = "calendarDate", class = "?" },
    { name = "cancel:", class = "?" },
    { name = "cancelNotification:", class = "?" },
    { name = "cgPDFDocument", class = "?" },
    { name = "dateByAddingYears:months:days:hours:minutes:seconds:", class = "?" },
    { name = "notificationDestroyed:", class = "?" },
    { name = "openWithURL:configuration:completionHandler:", class = "?" },
    { name = "plugInViewWithArguments:", class = "?" },
    { name = "pluginDestroy", class = "?" },
    { name = "pluginInitialize", class = "?" },
    { name = "pluginStart", class = "?" },
    { name = "pluginStop", class = "?" },
    { name = "pluginViewWithArguments:", class = "?" },
    { name = "policyForOrigin:", class = "?" },
    { name = "populateVisitedLinksForWebView:", class = "?" },
    { name = "rectValue", class = "?" },
    { name = "setCanDrawConcurrently:", class = "?" },
    { name = "setContainingWindow:", class = "?" },
    { name = "showNotification:fromWebView:", class = "?" },
    { name = "valueWithSize:", class = "?" },
    { name = "viewWillClose", class = "?" },
    { name = "webCryptoMasterKeyForWebView:", class = "?" },
    { name = "webFrame:didFinishLoadWithError:", class = "?" },
    { name = "webPlugInDestroy", class = "?" },
    { name = "webPlugInInitialize", class = "?" },
    { name = "webPlugInMainResourceDidFailWithError:", class = "?" },
    { name = "webPlugInMainResourceDidFinishLoading", class = "?" },
    { name = "webPlugInMainResourceDidReceiveData:", class = "?" },
    { name = "webPlugInMainResourceDidReceiveResponse:", class = "?" },
    { name = "webPlugInStart", class = "?" },
    { name = "webPlugInStop", class = "?" },
    { name = "webPlugInStopForPageCache", class = "?" },
    { name = "webThreadWebView:didLayout:", class = "?" },
    { name = "webThreadWebView:didLoadResourceFromMemoryCache:response:length:fromDataSource:", class = "?" },
    { name = "webThreadWebView:identifierForInitialRequest:fromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:didFailLoadingWithError:fromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:didFinishLoadingFromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:didReceiveContentLength:fromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:didReceiveResponse:fromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:willCacheResponse:fromDataSource:", class = "?" },
    { name = "webThreadWebView:resource:willSendRequest:redirectResponse:fromDataSource:", class = "?" },
    { name = "webThreadWebViewDidLayout:byScrolling:", class = "?" },
    { name = "webView:addMessageToConsole:", class = "?" },
    { name = "webView:decidePolicyForGeolocationRequestFromOrigin:frame:listener:", class = "?" },
    { name = "webView:decidePolicyForNotificationRequestFromOrigin:listener:", class = "?" },
    { name = "webView:didClickNotification:", class = "?" },
    { name = "webView:didCloseNotifications:", class = "?" },
    { name = "webView:didDrawFrame:", class = "?" },
    { name = "webView:didNavigateWithNavigationData:inFrame:", class = "?" },
    { name = "webView:didParseSource:baseLineNumber:fromURL:sourceId:forWebFrame:", class = "?" },
    { name = "webView:didParseSource:fromURL:sourceId:forWebFrame:", class = "?" },
    { name = "webView:didPerformClientRedirectFromURL:toURL:inFrame:", class = "?" },
    { name = "webView:didPerformServerRedirectFromURL:toURL:inFrame:", class = "?" },
    { name = "webView:didPressMissingPluginButton:", class = "?" },
    { name = "webView:didShowNotification:", class = "?" },
    { name = "webView:enterFullScreenForElement:listener:", class = "?" },
    { name = "webView:exceptionWasRaised:hasHandler:sourceId:line:forWebFrame:", class = "?" },
    { name = "webView:exceptionWasRaised:sourceId:line:forWebFrame:", class = "?" },
    { name = "webView:exitFullScreenForElement:listener:", class = "?" },
    { name = "webView:failedToParseSource:baseLineNumber:fromURL:withError:forWebFrame:", class = "?" },
    { name = "webView:frame:exceededDatabaseQuotaForSecurityOrigin:database:", class = "?" },
    { name = "webView:printFrame:", class = "?" },
    { name = "webView:shouldLoadMediaURL:inFrame:", class = "?" },
    { name = "webView:shouldPaintBrokenImageForURL:", class = "?" },
    { name = "webView:supportsFullScreenForElement:withKeyboard:", class = "?" },
    { name = "webView:updateHistoryTitle:forURL:", class = "?" },
    { name = "webView:updateHistoryTitle:forURL:inFrame:", class = "?" },
    { name = "webViewCanCheckGeolocationAuthorizationStatus:", class = "?" },
    { name = "sharedMappings", class = "?" },
    { name = "valueWithRect:", class = "?" },
    ]
symbols = [
    "_CFHTTPMessageSetResponseURL",
    "_CFNetworkIsKnownHSTSHostWithSession",
    "_CFURLCacheCopyCacheDirectory",
    "_kCFStreamSocketSetNoDelay",
    "kCFStreamPropertyCONNECTAdditionalHeaders",
    "kCFStreamPropertyCONNECTProxy",
    "kCFStreamPropertyCONNECTProxyHost",
    "kCFStreamPropertyCONNECTProxyPort",
    "kCFStreamPropertyCONNECTResponse",
    "kCFStreamPropertySourceApplication",
    "kCFStreamSocketSecurityLevelTLSv1_2",
    "kGSEventHardwareKeyboardAvailabilityChangedNotification",
    "CFHTTPCookieStorageSetCookieAcceptPolicy",
    "CFStringGetRangeOfCharacterClusterAtIndex",
    "CFURLCacheSetMemoryCapacity",
    "CGContextGetType",
    "CGContextSetBaseCTM",
    "MGGetBoolAnswer",
    "_CFURLStorageSessionCopyCookieStorage",
]

# The public iOS build uses CGGeometry methods instead of internal only NSGeometry methods.
# Clean up in rdar://6669434.
[[legacy]]
symbols = [
    "NSEqualPoints",
    "NSEqualSizes",
    "NSInsetRect",
    "NSIntersectionRect",
    "NSIsEmptyRect",
    "NSPointInRect",
    "NSZeroPoint",
    "NSZeroRect",
    "NSZeroSize",
]
requires = ["USE_APPLE_INTERNAL_SDK"]
