//@ requireOptions("--useWasmSIMD=1")
//@ skip if !$isSIMDPlatform
import { runSIMDTests } from "./simd-instructions-lib.js"

const verbose = false;

// Table-driven test data for SIMD logical instructions
// Each entry: [instruction, input0, input1, expected_output]
const logicalTests = [
    // v128.and test - covers various bit patterns: all 1s, all 0s, alternating, nibbles, single bits
    [
        "v128.and",
        [0xFF, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [0x0F, 0xFF, 0x55, 0xAA, 0x0F, 0xF0, 0x33, 0xCC, 0x40, 0x02, 0x80, 0x7F, 0xC3, 0x3C, 0x96, 0x69],
        [0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00]
    ],

    // v128.or test - covers complementary patterns and edge cases
    [
        "v128.or",
        [0xFF, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [0x0F, 0xFF, 0x55, 0xAA, 0x0F, 0xF0, 0x33, 0xCC, 0x40, 0x02, 0x80, 0x7F, 0xC3, 0x3C, 0x96, 0x69],
        [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // v128.xor test - covers self-XOR (result 0) and complementary patterns
    [
        "v128.xor",
        [0xFF, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [0x0F, 0xFF, 0xAA, 0xAA, 0x0F, 0xF0, 0x33, 0xCC, 0x40, 0x02, 0x80, 0x7F, 0xC3, 0x3C, 0x96, 0x69],
        [0xF0, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x03, 0xFF, 0x81, 0xFF, 0xFF, 0xFF, 0xFF]
    ],

    // v128.andnot test - first operand AND NOT second operand
    [
        "v128.andnot",
        [0xFF, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [0x0F, 0xFF, 0x55, 0xAA, 0x0F, 0xF0, 0x33, 0xCC, 0x40, 0x02, 0x80, 0x7F, 0xC3, 0x3C, 0x96, 0x69],
        [0xF0, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0x80, 0x3C, 0xC3, 0x69, 0x96]
    ],

    // v128.not test - bitwise NOT of 128-bit vector
    [
        "v128.not",
        [0x00, 0xFF, 0xAA, 0x55, 0x0F, 0xF0, 0x33, 0xCC, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80],
        [0xFF, 0x00, 0x55, 0xAA, 0xF0, 0x0F, 0xCC, 0x33, 0xFE, 0xFD, 0xFB, 0xF7, 0xEF, 0xDF, 0xBF, 0x7F] // Expected: bitwise NOT of input
    ],

    // v128.bitselect test - bitselect(a, b, c) = (a & c) | (b & ~c)
    // Comprehensive test with all bit combinations and varied selection mask
    [
        "v128.bitselect",
        [0xAA, 0x55, 0xFF, 0x00, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x7F, 0x01, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [0x55, 0xAA, 0x00, 0xFF, 0x0F, 0xF0, 0x33, 0xCC, 0x7F, 0x80, 0xFE, 0x01, 0xC3, 0x3C, 0x96, 0x69],
        [0xF0, 0x0F, 0xAA, 0x55, 0xFF, 0x00, 0xC3, 0x3C, 0x81, 0x7E, 0x42, 0xBD, 0x18, 0xE7, 0x24, 0xDB],
        [0xA5, 0xA5, 0xAA, 0xAA, 0xF0, 0xF0, 0xF0, 0xF0, 0xFE, 0xFE, 0xBC, 0xBC, 0xDB, 0xDB, 0xB2, 0xB2]   // expected: (a & c) | (b & ~c)
    ],

    // v128.any_true
    [
        "v128.any_true",
        [0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        1
    ],
    [
        "v128.any_true",
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        0
    ],

    // i8x16.popcnt - population count (count set bits) for each 8-bit lane
    [
        "i8x16.popcnt",
        [0xFF, 0x00, 0xAA, 0x55, 0xF0, 0x0F, 0xCC, 0x33, 0x80, 0x01, 0x7F, 0xFE, 0x3C, 0xC3, 0x69, 0x96],
        [8, 0, 4, 4, 4, 4, 4, 4, 1, 1, 7, 7, 4, 4, 4, 4]
    ],

    // i8x16.all_true - return 1 if all 16 8-bit lanes are non-zero, 0 otherwise
    [
        "i8x16.all_true",
        [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10],
        1
    ],
    [
        "i8x16.all_true",
        [0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x00, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F],
        0
    ],

    // i8x16.bitmask - extract most significant bit from each 8-bit lane
    [
        "i8x16.bitmask",
        [0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00],
        0x5555  // 0101010101010101 in binary
    ],
    [
        "i8x16.bitmask",
        [0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F, 0xFF, 0x7F],
        0x5555  // 0101010101010101 in binary
    ],
    [
        "i8x16.bitmask",
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        0x0000
    ],
    [
        "i8x16.bitmask",
        [-10, -20, -30, 40, 50, 60, -70, -80, 90, 100, 110, -120, 13, 14, 15, -16],
        0x88C7  // bits 0,1,2,6,7,11,15 set
    ],

    // i16x8.all_true - return 1 if all 8 16-bit lanes are non-zero, 0 otherwise
    [
        "i16x8.all_true",
        [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008],
        1
    ],
    [
        "i16x8.all_true",
        [0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0000],
        0
    ],

    // i16x8.bitmask - extract most significant bit from each 16-bit lane
    [
        "i16x8.bitmask",
        [0x8000, 0x0000, 0x8000, 0x0000, 0x8000, 0x0000, 0x8000, 0x0000],
        0x55  // 01010101 in binary
    ],
    [
        "i16x8.bitmask",
        [1000, 2000, -3000, -4000, -5000, 6000, -7000, -8000],
        0xDC  // bits 2,3,4,6,7 set
    ],

    // i32x4.all_true - return 1 if all 4 32-bit lanes are non-zero, 0 otherwise
    [
        "i32x4.all_true",
        [0x00000001, 0x00000002, 0x00000003, 0x00000004],
        1
    ],
    [
        "i32x4.all_true",
        [0x00000001, 0x00000002, 0x00000003, 0x00000000],
        0
    ],

    // i32x4.bitmask - extract most significant bit from each 32-bit lane
    [
        "i32x4.bitmask",
        [0x80000000, 0x00000000, 0x80000000, 0x00000000],
        0x5  // 0101 in binary
    ],
    [
        "i32x4.bitmask",
        [-42, -73, -128, -1],
        0xF  // all negative values -> all bits set
    ],
    [
        "i32x4.bitmask",
        [-100000, 200000, 300000, -400000],
        0x9  // negative values at positions 0,3 -> bits 0,3 set
    ],

    // i64x2.all_true - return 1 if all 2 64-bit lanes are non-zero, 0 otherwise
    [
        "i64x2.all_true",
        [0x0000000000000001n, 0x0000000000000002n],
        1
    ],
    [
        "i64x2.all_true",
        [0x0000000000000001n, 0x0000000000000000n],
        0
    ],

    // i64x2.bitmask - extract most significant bit from each 64-bit lane
    [
        "i64x2.bitmask",
        [0x0000000000000000n, 0x0000000000000000n],
        0x0
    ],
    // i64x2.bitmask with varied positive and negative values creating different patterns
    [
        "i64x2.bitmask",
        [-9223372036854775808n, 9223372036854775807n],  // Most negative and most positive 64-bit values
        0x1  // negative value in lane 0 -> bit 0 set
    ],
    [
        "i64x2.bitmask",
        [1234567890123456789n, -987654321098765432n],
        0x2  // negative value in lane 1 -> bit 1 set
    ]
];

await runSIMDTests(logicalTests, verbose, "SIMD bitwise");
